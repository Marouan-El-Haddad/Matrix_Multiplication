/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package matrix;

import java.io.*;

public class Matrix {
    /**
     * number of rows in the matrix
     */
    public int rows = 0;
    /**
     * number of columns in the matrix
     */
    public int cols = 0;
    /**
     * reference to underlying data (can be much larger than rows * columns)
     */
    public double[] data = null;
    /**
     * Index of the first element (0,0) in the data array
     */
    public int start = 0;
    /**
     * Underlying row length (the distance from (i,j) to (i+1,j) in the data
     * array)
     */
    public int stride = 0;

    /**
     * The full constructor
     * @param rows rows
     * @param cols columns
     * @param data reference to data
     * @param start start index
     * @param stride stride length
     */
    public Matrix(int rows, int cols, double[] data, int start, int stride) {
        this.rows = rows;
        this.cols = cols;
        this.data = data;
        this.start = start;
        this.stride = stride;
    }

    /**
     * Initializes an rows * cols matrix of zeros
     * @param rows rows
     * @param cols columns
     */
    public Matrix(int rows, int cols) {
        this(rows, cols, new double[rows*cols], 0, cols);
    }

    /**
     * Initializes a rows * cols matrix with the given array of length
     * rows*cols
     * @param rows rows
     * @param cols columns
     * @param data data array of length rows*cols
     */
    public Matrix(int rows, int cols, double[] data) {
        this(rows, cols, data, 0, cols);
    }

    /**
     * Initializes an empty matrix
     */
    public Matrix() {

    }
    /**
     * Returns a string representation of the matrix
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < rows; ++i) {
            if (i > 0)
                sb.append('\n');
            for (int j = 0; j < cols; ++j) {
                if (j > 0)
                    sb.append(" ");
                sb.append(data[start + i*stride + j]);
            }
        }
        return sb.toString();
    }

    /**
     * A slow bounds-checked helper function to get an element in the array.
     * This function is only good for debugging purposes, don't use in your
     * matrix multiplication routines.
     * @param i row
     * @param j column
     * @return Element at (i,j)
     */
    public double getSlow(int i, int j) {
        if (i < 0 || i >= rows || j < 0 || j >= cols) {
            throw new ArrayIndexOutOfBoundsException();
        }
        return data[start + i*stride + j];
    }
    public double[] getData(){
        return data;
    }

    /**
     * A slow bounds-checked helper function to set an element in the array.
     * This function is only good for debugging purposes, don't use in your
     * matrix multiplication routines.
     * @param i row
     * @param j column
     * @param v Value to set at (i,j)
     */
    public void setSlow(int i, int j, double v) {
        if (i < 0 || i >= rows || j < 0 || j >= cols) {
            throw new ArrayIndexOutOfBoundsException();
        }
        data[start + i*stride + j ] = v;
    }

    /**
     * @return Returns a deep copy of the matrix
     */
    public Matrix copy() {
        Matrix A = new Matrix(rows,cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                A.data[i*cols + j] = data[start + i*stride + j];
            }
        }
        return A;
    }
    /**
     * Performs the O(n^3) elementary multiplication with three nested loops.
     * @param A Left-hand input of size n*m.
     * @param B Right-hand input of size m*p.
     * @return Matrix C of size n*p satisfying C=AB.
     */
    public static Matrix elementaryMultiplication(Matrix A, Matrix B) {
        Matrix C = new Matrix(A.rows, B.cols);

        for (int i = 0; i < A.rows; ++i) {
            for (int j = 0; j < B.cols; ++j) {
                for (int k = 0; k < A.cols; ++k) {
                    int aIndex = (i * A.stride + k)+A.start;
                    int bIndex = (k * B.stride + j)+B.start;
                    int cIndex = i * B.cols + j;
                    C.data[cIndex] += A.data[aIndex] * B.data[bIndex];
                }
            }
        }
        return C;
    }

    /**
     * Performs the O(n^3) elementary matrix multiplication in place, that is,
     * computes C += AB. Importantly, the matrix C must be of correct shape,
     * and it is *not* zeroed; this enables us to accumulate products.
     * @param C Output matrix
     * @param A Left-hand operand
     * @param B Right-hand operand
     */
    public static void elementaryMultiplication(Matrix A, Matrix B, Matrix C) {
        C.add(elementaryMultiplication(A,B));
    }

    /**
     * Returns a transposed copy of the matrix.
     * @return A transposed copy of the matrix.
     */
    public Matrix transpose() {
        Matrix A_transposed = new Matrix(cols, rows);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                A_transposed.data[j*rows + i] = data[start + i*stride + j];
            }
        }
        return A_transposed;
    }


    /**
     * Stores a transposed version of the matrix A into B. Assuming A has
     * m rows and n cols, B should have n rows and m cols. The function does
     * not reallocate any data in B, but simply stores the transposed matrix
     * *in* B.
     * @param A
     * @param B
     */
    public static void transpose(Matrix A, Matrix B) {
        if (A.rows != B.cols || A.cols != B.rows) {
            throw new IllegalArgumentException("Matrix dimensions do not match");
        }
        double[] arrA = A.transpose().getData();
        double[] arrB = B.getData();
        for (int i = 0; i < A.cols; i++) {
            for (int j = 0; j < A.rows; j++) {
                arrB[B.start+j+i*A.stride] = arrA[j+A.rows*i];
            }
        }
    }

    /**
     * Recursive transpose
     * @param A Input matrix
     * @param B Output matrix (must be of correct shape)
     * @param s Minimum size: if the subproblem size is at most this, then the
     * regular transpose is called.
     */
    public static void transposeRec(Matrix A, Matrix B, int s) {
        if (A.rows <= s) {
            transpose(A,B);
        } else {
            //Split A into 4 submatrices
            Matrix A11 = A.view(0, 0, A.rows/2, A.cols/2);
            Matrix A12 = A.view(0, A.cols/2, A.rows/2, A.cols/2);
            Matrix A21 = A.view(A.rows/2, 0, A.rows/2, A.cols/2);
            Matrix A22 = A.view(A.rows/2, A.rows/2, A.rows/2, A.cols/2);
            
            //Split B into 4 submatrices
            Matrix B11 = B.view(0, 0, B.rows/2, B.cols/2);
            Matrix B12 = B.view(0, B.cols/2, B.rows/2, B.cols/2);
            Matrix B21 = B.view(B.rows/2, 0, B.rows/2, B.cols/2);
            Matrix B22 = B.view(B.rows/2, B.rows/2, B.rows/2, B.cols/2);
            
            //Recursively transpose the submatrices
            transposeRec(A11, B11, s);
            transposeRec(A12, B21, s);
            transposeRec(A21, B12, s);
            transposeRec(A22, B22, s);
        }
    }

    /**
     * Performs the O(n^3) elementary multiplication with three nested loops.
     * A transposed copy of the right-hand operand is constructed before
     * computing the multiplication, using the transposeRec function.
     * @param A Left-hand input of size n*m.
     * @param B Right-hand input of size m*p.
     * @param s The minimum size parameter for transposeRec.
     * @return Matrix C of size n*p satisfying C=AB.
     */
    public static Matrix elementaryMultiplicationTransposed(Matrix A, Matrix B, int s) {
        Matrix B_transposed = new Matrix(B.cols, B.rows);
        transposeRec(B, B_transposed, s);

        Matrix C = new Matrix(A.rows, B.cols);
        for (int i = 0; i < A.rows; ++i) {
            for (int j = 0; j < B.cols; ++j) {
                for (int k = 0; k < A.cols; ++k) {
                    C.data[i*B.cols + j] += A.data[i* A.cols + k] * B_transposed.data[j * B_transposed.cols + k];
                }
            }
        }
        return C;
    }

    /**
     * Performs tiled matrix multiplication using a tile size of s*s.
     * @param A Left-hand input.
     * @param B Right-hand input.
     * @param s Tile size.
     * @return Matrix C satisfying C=AB.
     */
    public static Matrix tiledMultiplication(Matrix A, Matrix B, int s) {
        int n = A.rows/s;
        Matrix C = new Matrix(A.rows, A.rows);

        //for each tile
        for (int i0 = 0; i0 < n; ++i0) {
            for (int j0 = 0; j0 < n; ++j0) {
                for (int k0 = 0; k0 < n; ++k0) {

                    //perform matrix multiplication within each tile
                    for (int i = i0*s; i < (i0+1)*s; ++i) {
                        for (int j = j0*s; j < (j0+1)*s; ++j) {
                            for (int k = k0*s; k < (k0+1)*s; ++k) {
                                C.data[i*(n*s) + j] += A.data[i*(n*s) + k] * B.data[k*(n*s) + j];
                            }
                        }
                    }

                }
            }
        }
        return C;
    }

    /**
     * Returns a view (a shallow matrix header) of the submatrix with the
     * given number of rows and columns whose upper-left corner is at (i0,j0).
     * No data is copied.
     * @param i0 Upper-left row.
     * @param j0 Upper-left column.
     * @param rows Number of rows.
     * @param cols Number of columns.
     * @return A shallow view of the submatrix.
     */
    public Matrix view(int i0, int j0, int rows, int cols) {
        return new Matrix(rows, cols, data, start + stride*i0 + j0, stride);
    }

    /**
     * Recursive matrix multiplication
     * @param A Left-hand operand
     * @param B Right-hand operand
     * @param C Output matrix
     * @param s Subproblem size
     */
    public static void recursiveMultiplication(Matrix A, Matrix B, Matrix C, int s) {
        int n = A.rows;
        if (n == 1) {
            C.data[C.start] += A.data[A.start] * B.data[B.start]; //scalar multiplication
        }
        else if (n <= s){
            elementaryMultiplication(A, B, C); //non-trivial multiplication
        }
         else {
            //split A into 4 submatricies
            Matrix A11 = A.view(0, 0, A.rows / 2, A.cols / 2);
            Matrix A12 = A.view(0, A.cols / 2, A.rows / 2, A.cols / 2);
            Matrix A21 = A.view(A.rows / 2, 0, A.rows / 2, A.cols / 2);
            Matrix A22 = A.view(A.rows / 2, A.cols / 2, A.rows / 2, A.cols / 2);

            //Split B into 4 submatrices
            Matrix B11 = B.view(0, 0, B.rows / 2, B.cols / 2);
            Matrix B12 = B.view(0, B.cols / 2, B.rows / 2, B.cols / 2);
            Matrix B21 = B.view(B.rows / 2, 0, B.rows / 2, B.cols / 2);
            Matrix B22 = B.view(B.rows / 2, B.cols / 2, B.rows / 2, B.cols / 2);
            
            //Split C into 4 submatrices
            Matrix C11 = C.view(0, 0, A.rows / 2, A.cols / 2);
            Matrix C12 = C.view(0, A.cols / 2, A.rows / 2, A.cols / 2);
            Matrix C21 = C.view(A.rows / 2, 0, A.rows / 2, A.cols / 2);
            Matrix C22 = C.view(A.rows / 2, A.cols / 2, A.rows / 2, A.cols / 2);
            
            //recursive calls
            recursiveMultiplication(A11, B11, C11,s);
            recursiveMultiplication(A12, B21, C11,s);
            recursiveMultiplication(A11, B12, C12,s);
            recursiveMultiplication(A12, B22, C12,s);
            recursiveMultiplication(A21, B11, C21,s);
            recursiveMultiplication(A22, B21, C21,s);
            recursiveMultiplication(A21, B12, C22,s);
            recursiveMultiplication(A22, B22, C22,s);
        }
    }

    /**
     * Computes the matrix product using Strassen's algorithm.
     * @param A Left-hand operand
     * @param B Right-hand operand
     * @param C Output matrix such that C=AB
     * @param s Minimum size for recursion: for subproblem sizes at most this,
     * an O(n^3) algorithm will be used.
     */
    public static void strassen(Matrix A, Matrix B, Matrix C, int s) {
        /* Fill here the missing implementation */
    }

    /**
     * Set all elements of the matrix equal to v.
     * @param v Target value.
     */
    public void setAll(double v) {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                data[start + i*stride + j] = v;
            }
        }
    }

    /**
     * Computes A += B in-place
     * @param B The right-hand-side operand
     */
    public void add(Matrix B) {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                int bIndex = j+i*B.stride;
                int thisIndex = (j+i*this.stride)+this.start;
                this.data[thisIndex] = this.data[thisIndex] + B.data[bIndex];
            }
        }
    }

    /**
     * Returns a new matrix C satisfying C = A+B
     * @param A Left-hand operand
     * @param B Right-hand operand
     * @return Matrix C satisfying C=A+B
     */
    public static Matrix add(Matrix A, Matrix B) {
        Matrix C = A.copy();
        C.add(B);
        return C;
    }

    /**
     * Stores A+B into C. Shapes of all matrices must match.
     * @param A Left-hand operand
     * @param B Right-hand operand
     * @param C Output matrix
     */
    public static void add(Matrix A, Matrix B, Matrix C) {
        C.add(A);
        C.add(B);
    }

    /**
     * Computes A -= B in-place
     * @param B The right-hand-side operand
     */
    public void sub(Matrix B) {
        /* Fill here the missing implementation */
    }

    /**
     * Returns a new matrix C satisfying C = A-B
     * @param A Left-hand operand
     * @param B Right-hand operan
     * @return Matrix C satisfying C=A-B
     */
    public static Matrix sub(Matrix A, Matrix B) {
        /* Fill here the missing implementation */
        return null;
    }

    /**
     * Stores A-B into C. Shapes of all matrices must match.
     * @param A Left-hand operand
     * @param B Right-hand operand
     * @param C Output matrix
     */
    public static void sub(Matrix A, Matrix B, Matrix C) {
        /* Fill here the missing implementation */
    }

    /**
     * Returns true iff that is a Matrix that corresponds in shape to this and
     * all elements of this and that compare equal.
     * @param that The right hand side operand
     */
    @Override
    public boolean equals(Object that) {
        if (!(that instanceof Matrix))
            return false;
        Matrix M = (Matrix)that;
        if (cols != M.cols)
            return false;
        if (rows != M.rows)
            return false;
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (data[start + i*stride + j] != M.data[M.start+i*M.stride+j])
                    return false;
            }
        }
        return true;
    }
}
