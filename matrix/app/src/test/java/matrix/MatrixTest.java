/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package matrix;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class MatrixTest {

    //matrix with 2x2 with values multA:1,2,3,4, multB: 5,6,7,8, multC: 0,0,0,0
    Matrix multA = new Matrix(2, 2);
    Matrix multB = new Matrix(2, 2);
    Matrix multC = new Matrix(2, 2);

    //correct and false results for matrix multiplication of multA and multB
    Matrix matMultCorResult = new Matrix(2, 2);
    Matrix matMultFalseResult = new Matrix(2, 2);

    //empty 2x2 matrices
    Matrix emptyA = new Matrix(2, 2);
    Matrix emptyB = new Matrix(2, 2);
    Matrix emptyC = new Matrix(2, 2);

    //correct and false results for transpose of multA and multB
    Matrix transCorResult = new Matrix(2, 2);
    Matrix transFalseResult = new Matrix(2, 2);

    //Matrix for transposeRec and elementaryMultiplicationTransposed size 144x144
    Matrix recA = new Matrix(144, 144);
    Matrix recB = new Matrix(144, 144);

    //correct and false results for transposeRec size 144x144
    Matrix transrecCorResult = new Matrix(144, 144);

    //correct and false results for elementaryMultiplicationTransposed size 144x144
    Matrix nonTransposed_A = new Matrix(144, 144);
    Matrix transposedB_Mult = new Matrix(144, 144);
    Matrix elemTransMult_finalCorResult = new Matrix(144, 144);
    Matrix transAndmultFalse = new Matrix(144, 144);

    //correct result for addition
    Matrix addCorResult = new Matrix(2,2);

    //initialize aTiledMult and bTiledMult, having the values: aTile = 1 - 16, bTile = 17 - 32
    Matrix aTiledMult = new Matrix(4, 4);
    Matrix bTiledMult = new Matrix(4, 4);

    //initialize 8x8 matrices for recursiveMultiplication
    Matrix A8x8 = new Matrix(8,8);
    Matrix B8x8 = new Matrix(8,8);
    Matrix C8x8one = new Matrix(8,8);
    Matrix C8x8two = new Matrix(8,8);

    @Before
    public void setup() {
        //insert values for multA and multB
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= 2; j++) {
                multA.setSlow(i, j-1, (j + i * 2.0));
                multB.setSlow(i, j-1, (j + i * 2.0 + 4.0));
            }
        }

        //insert correct values for matrix multiplication of multA and multB
        matMultCorResult.setSlow(0,0,19.0);
        matMultCorResult.setSlow(0,1,22.0);
        matMultCorResult.setSlow(1,0,43.0);
        matMultCorResult.setSlow(1,1,50.0);

        //insert false values for matrix multiplication of multA and multB
        matMultFalseResult.setSlow(0,0,5.0);
        matMultFalseResult.setSlow(0,1,6.0);
        matMultFalseResult.setSlow(1,0,7.0);
        matMultFalseResult.setSlow(1,1,8.0);

        //insert correct values for transpose of multA and multB
        transCorResult.setSlow(0,0,1.0);
        transCorResult.setSlow(0,1,3.0);
        transCorResult.setSlow(1,0,2.0);
        transCorResult.setSlow(1,1,4.0);

        //insert false values for transpose of multA and multB
        transFalseResult.setSlow(0,0,1.0);
        transFalseResult.setSlow(0,1,2.0);
        transFalseResult.setSlow(1,0,3.0);
        transFalseResult.setSlow(1,1,4.0);

        //insert correct values for the add function
        addCorResult.setSlow(0,0,6);
        addCorResult.setSlow(0,1,8);
        addCorResult.setSlow(1,0,10);
        addCorResult.setSlow(1,1,12);

        // insert values for recA and recB
        for (int i = 0; i < 144; i++) {
            for (int j = 1; j <= 144; j++) {
                recA.setSlow(i, j-1, (j + i * 144.0));
                recB.setSlow(i, j-1, (j + i * 144.0 + (144*144)));
            }
        }

        // TransposeRec insertion for "correct values"
        for (int i = 0; i < 144 ; i++) {
            for (int j = 0; j < 144; j++) {
                transrecCorResult.setSlow(i, j, ((j*144.0)+1.0) +i);
            }
        }

        //elementaryMultiplicationTransposed, transposed 1-144
        for (int i = 0; i < 144 ; i++) {
            for (int j = 0; j < 144; j++) {
                transposedB_Mult.setSlow(i, j, ((j*144.0)+1.0) +i);
                nonTransposed_A.setSlow(i,j,(j+1.0)*i);
            }
        }

        //elementaryMultiplicationTransposed, correct result
        elemTransMult_finalCorResult = Matrix.elementaryMultiplication(nonTransposed_A, transposedB_Mult);

        //elementaryMultiplicationTransposed, false result
        for (int i = 0; i < 144 ; i++) {
            for (int j = 0; j < 144; j++) {
                transAndmultFalse.setSlow(i,j,(j+1.0)*i);
            }
        }

        //insert values for aTiledMult and bTiledMult
        for (int i = 0; i < 4; i++) {
            for (int j = 1; j <= 4; j++) {
                aTiledMult.setSlow(i, j-1, (j + i * 2.0));
                bTiledMult.setSlow(i, j-1, (j + i * 2.0 + 4.0));
            }
        }

        //insert values for A8x8 and B8x8
        for (int i = 0; i < 8; i++) {
            for (int j = 1; j <= 8; j++) {
                A8x8.setSlow(i, j-1, (j + i * 8.0));
                B8x8.setSlow(i, j-1, (j + i * 8.0 + 64.0));
            }
        }
    }
    @Test
    public void test_getData_noArg(){
        //test if multA.getData() is not null
        assertNotNull(multA.getData());

        //test if getData() returns the correct data
        double[] data = multA.getData();
        double[] expected = {1.0, 2.0, 3.0, 4.0};
        assertArrayEquals(expected, data, 0.0);
    }
    @Test
    public void test_ElementaryMultiplication_AB() {
        //test if multA, multB, matMultCorResult, matMultFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(matMultCorResult);
        assertNotNull(matMultFalseResult);

        //compute the result of elementaryMultiplication using multA and multB
        Matrix result = Matrix.elementaryMultiplication(multA, multB);

        //test if the result is not null
        assertNotNull(result);

        //compute the result of elementaryMultiplication using emptyA and emptyB
        Matrix result2 = Matrix.elementaryMultiplication(emptyA, emptyB);

        //test if the result2 is not null
        assertNotNull(result2);


        //test if the result of elementaryMultiplication is equal to the correct result
        assertEquals(result, matMultCorResult);
        assertEquals(result2, emptyA);
        assertEquals(result2, emptyB);

        //test if the result of elementaryMultiplication is not equal to false result
        assertNotEquals(result, matMultFalseResult);
        assertNotEquals(emptyA, matMultCorResult);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size (a condition in our transpose method)
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.elementaryMultiplication(C8x8one,multA);
        });
    }
    @Test
    public void test_ElementaryMultiplication_ABC() {
        //test if multA, multB, multC, matMultCorResult, matMultFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(multC);
        assertNotNull(matMultCorResult);
        assertNotNull(matMultFalseResult);

        //compute the result of elementaryMultiplication using multA, multB and multC
        Matrix.elementaryMultiplication(multA, multB, multC);

        //compute the result of elementaryMultiplication using emptyA, emptyB and emptyC
        Matrix.elementaryMultiplication(emptyA, emptyB, emptyC);

        //test if the result of elementaryMultiplication is equal to the correct result
        assertEquals(emptyA, emptyA);
        assertEquals(emptyA, emptyB);
        assertEquals(emptyA, emptyC);
        assertEquals(emptyB, emptyB);
        assertEquals(emptyB, emptyC);
        assertEquals(emptyC, emptyC);
        assertEquals(multC, matMultCorResult);

        //test if the result of elementaryMultiplication is not equal to false result
        assertNotEquals(emptyC, matMultCorResult);
        assertNotEquals(multC, matMultFalseResult);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size (a condition in our transpose method)
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.elementaryMultiplication(C8x8one,multA, multC);
        });
    }
    @Test
    public void test_Transpose_noArg() {
        //test if multA, transCorResult, transFalseResult are not null
        assertNotNull(multA);
        assertNotNull(transCorResult);
        assertNotNull(transFalseResult);

        //compute the result of transpose using multA
        Matrix result = multA.transpose();
        //compute the result of transpose using emptyA
        Matrix result2 = emptyA.transpose();

        //test if the results are not null
        assertNotNull(result);
        assertNotNull(result2);

        //test if the results of transpose is equal to the correct result
        assertEquals(result2, emptyB);
        assertEquals(result, transCorResult);

        //test if the results of transpose is not equal to the false result
        assertNotEquals(result2, transCorResult);
        assertNotEquals(result, transFalseResult);
    }
    @Test
    public void test_Transpose_AB() {
        //test if multA, multB, transCorResult, transFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(transCorResult);
        assertNotNull(transFalseResult);

        //compute the result of transpose using multA and multB
        Matrix.transpose(multA, multB);

        //test if the results of transpose is equal to the correct result
        assertEquals(multB, transCorResult);

        //test if the results of transpose is not equal to the false result
        assertNotEquals(multB, transFalseResult);
        assertNotEquals(multA, transCorResult);
        assertNotEquals(multB, emptyB);

        //test if IllegalArgumentException will be thrown if matrices are not of the same size (a condition in our transpose method)
        assertThrows(IllegalArgumentException.class, () -> {
            Matrix.transpose(C8x8one,nonTransposed_A);
        });
    }
    @Test
    public void test_transposeRec_ABs() {
        //test if transCorResult, transFalseResult, recA, recB are not null
        assertNotNull(transCorResult);
        assertNotNull(transFalseResult);
        assertNotNull(recA);
        assertNotNull(recB);

        //compute the result of transposeRec using recA and recB
        Matrix.transposeRec(recA, recB,36);

        //compute the result of transposeRec using emptyA and emptyB
        Matrix.transposeRec(emptyA, emptyB,36);


        //test if the results of transposeRec is equal to the correct result
        assertEquals(recB, transrecCorResult);
        assertEquals(emptyB, emptyC);

        //test if the results of transposeRec is not equal to the false result
        assertNotEquals(recB, transAndmultFalse);
        assertNotEquals(emptyB,transCorResult);
        assertNotEquals(recA, transrecCorResult);

        //test if IllegalArgumentException will be thrown if matrices are not of the same size (a condition in our transpose method)
        assertThrows(IllegalArgumentException.class, () -> {
            Matrix.transposeRec(C8x8one,nonTransposed_A,36);
        });
    }
    @Test
    public void test_elementaryMultiplicationTransposed_ABs() {
        //test if elemTransMult_finalCorResult, transAndmultFalse, nonTransposed_A, transposedB_Mult are not null
        assertNotNull(elemTransMult_finalCorResult);
        assertNotNull(transAndmultFalse);
        assertNotNull(nonTransposed_A);
        assertNotNull(transposedB_Mult);

        //compute the result of elementaryMultiplicationTransposed using nonTransposed_A and transposedB_Mult
        Matrix result = Matrix.elementaryMultiplicationTransposed(nonTransposed_A, transposedB_Mult,36);

        //compute the result of elementaryMultiplicationTransposed using emptyA and emptyB
        Matrix result2 = Matrix.elementaryMultiplicationTransposed(emptyA, emptyB,36);


        //test if the results of elementaryMultiplicationTransposed is equal to the correct result
        assertEquals(result, elemTransMult_finalCorResult);
        assertEquals(result2,emptyC);

        //test if the results of elementaryMultiplicationTransposed is not equal to the false result
        assertNotEquals(result2,elemTransMult_finalCorResult);
        assertNotEquals(result, transFalseResult);
        assertNotEquals(result, nonTransposed_A);
        assertNotEquals(result, transposedB_Mult);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.elementaryMultiplicationTransposed(nonTransposed_A, C8x8one,36);
        });
    }
    @Test
    public void test_add_B() {
        //test if multA, multB, addCorResult, matMultFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(addCorResult);
        assertNotNull(matMultFalseResult);

        //test if multA and addCorResult are not equal before operation
        assertNotEquals(multA, addCorResult);

        //compute the result of add using multA and multB
        multA.add(multB);

        //test if the result of add is equal to the correct result
        assertEquals(multA, addCorResult);

        //test if the result of add is not equal to the false result
        assertNotEquals(multA, matMultFalseResult);
        assertNotEquals(multA, multB);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            B8x8.add(multA);
        });
    }
    @Test
    public void test_add_AB() {
        //test if multA, multB, addCorResult, matMultFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(addCorResult);
        assertNotNull(matMultFalseResult);

        //test if multA and addCorResult are not equal before operation
        assertNotEquals(multA, addCorResult);

        //compute the result of add using multA and multB
        Matrix result = Matrix.add(multA, multB);

        //test if the result of add is equal to the correct result
        assertEquals(result, addCorResult);

        //test if the result of add is not equal to the false result
        assertNotEquals(result, matMultFalseResult);
        assertNotEquals(result, multB);
        assertNotEquals(result, multA);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.add(B8x8, multA);
        });
    }
    @Test
    public void test_add_ABC(){
        //test if multA, multB, multC, addCorResult, matMultFalseResult are not null
        assertNotNull(multA);
        assertNotNull(multB);
        assertNotNull(multC);
        assertNotNull(addCorResult);
        assertNotNull(matMultFalseResult);

        //test if multC and addCorResult are not equal before operation
        assertNotEquals(multC, addCorResult);

        //compute the result of add using multA, multB and multC
        Matrix.add(multA, multB, multC);

        //test if the result of add is equal to the correct result
        assertEquals(multC, addCorResult);

        //test if the result of add is not equal to the false result
        assertNotEquals(multC, matMultFalseResult);
        assertNotEquals(multC, multB);
        assertNotEquals(multC, multA);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.add(B8x8, multA, C8x8one);
        });
    }
    @Test
    public void test_InputDataGenerator_RCs() {
        //intialize the input data generator
        InputDataGenerator generator = new InputDataGenerator();

        //create size 8x8 matrices using the input data generator: matrixA (seed 123), matrixB (seed 456) and matrixC (seed 123).
        Matrix matrixA = generator.matrixGenerator(8,8, 123);
        Matrix matrixB = generator.matrixGenerator(8,8, 456);
        Matrix matrixC = generator.matrixGenerator(8,8, 123);

        //check if the matrices are not null
        assertNotNull(matrixA);
        assertNotNull(matrixB);
        assertNotNull(matrixC);

        //test if the matrices are of the correct row and column length
        assertEquals(8, matrixA.rows);
        assertEquals(8, matrixA.cols);
        assertEquals(8, matrixB.rows);
        assertEquals(8, matrixB.cols);

        //test if matrixA and matrixB are equal to each other as they use the same seed
        assertEquals(matrixA, matrixC);

        //test if matrixA and matrixB are not equal to each other as they use different seeds
        assertNotEquals(matrixA, matrixB);
    }
    @Test
    public void test_TiledMult() {
        //test if aTiledMult, bTiledMult are not null
        assertNotNull(aTiledMult);
        assertNotNull(bTiledMult);

        //compute the tiled multiplication of aTiledMult and bTiledMult with a s parameter value of 2
        Matrix bilC = Matrix.tiledMultiplication(aTiledMult, bTiledMult, 2);

        //create a correct result matrix using elementaryMultiplication
        Matrix bilCCorrect = Matrix.elementaryMultiplication(aTiledMult, bTiledMult);

        //test if the result of tiledMultiplication is equal to the correct result
        assertEquals(bilCCorrect, bilC);

        //test if the result of tiledMultiplication is not equal to the false result
        assertNotEquals(bilC, aTiledMult);
        assertNotEquals(bilC, bTiledMult);
        assertNotEquals(bilC, emptyC);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.tiledMultiplication(aTiledMult, emptyC,2);
        });
    }
    @Test
    public void test_recursiveMultiplication_ABC() {
        //test if A8x8, B8x8, C8x8one, C8x8two are not null
        assertNotNull(A8x8);
        assertNotNull(B8x8);
        assertNotNull(C8x8one);
        assertNotNull(C8x8two);

        //compute the correct result of A8x8 and B8x8 using elementaryMultiplicationTransposed
        Matrix corrResult8x8 = Matrix.elementaryMultiplication(A8x8, B8x8);

        //compute the result of A8x8, B8x8 and C8x8one using recursiveMultiplication with no recursive calls, s parameter value of 8
        Matrix.recursiveMultiplication(A8x8, B8x8,C8x8one,8); //no recursive calls will be made

        //compute the result of A8x8, B8x8 and C8x8two using recursiveMultiplication with recursive calls, s parameter value of 2
        Matrix.recursiveMultiplication(A8x8, B8x8,C8x8two,2); //recursive calls will be made

        //test if the result of recursiveMultiplication with no recursive is equal to the correct result
        assertEquals(corrResult8x8, C8x8one);

        //test if the result of recursiveMultiplication with recursive calls is equal to the correct result
        assertEquals(corrResult8x8, C8x8two);

        //test if the result of recursiveMultiplication with no recursive is not equal to the false result
        assertNotEquals(C8x8one, A8x8);
        assertNotEquals(C8x8one, B8x8);
        assertNotEquals(C8x8one, emptyC);

        //test if the result of recursiveMultiplication with recursive calls is not equal to the false result
        assertNotEquals(C8x8two, A8x8);
        assertNotEquals(C8x8two, B8x8);
        assertNotEquals(C8x8two, emptyC);

        //test if ArrayIndexOutOfBoundsException will be thrown if matrices are not of the same size
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            Matrix.recursiveMultiplication(A8x8, emptyC, C8x8one, 2);
        });
    }
}
